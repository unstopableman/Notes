# Java自学笔记

## 一、Java语言概述

### 1.Java的特点

​	1.平台无关性

​	2.面对对象

​		（1）封装

​		（2）继承

​		（3）多态

​	3.多线程	

​	4.安全

​	5.动态

### 2.Java程序开发

​	一个Java应用程序必须有一个类含有public static void main(String args[])方法。这个类称应用程序的主类。args[]是main方法的一个参数，是一个字符串类型的数组。

​	源文件的命名规则：

​	（1）如果源文件中有多个类，那么只能有一个类是public类。

​	（2）如果有一个类是public类，那么源文件的名字必须与这个类的名字完全相同，拓展名为  .java

​	（3）如果源文件没有public类，那么源文件的名字只要与某个类的名字相同，并且拓展名是 .java 就可以了

Java语言是区分大小写的。

## 二、基本数据类型和数组

### 1.标识符和关键字

#### 1.标识符

​	Java语言规定标识符由字母、下划线、美元符号和数字组成，并且第一个字符不能是数字。

​	（1）长度不受限制

​	（2）第一个字符不能是数字

​	（3）标识符不能是关键字

​	（4）标识符不能是true、false、和null

​	（5）标识符中的字母是区分大小写的

#### 2.关键字

​	关键字就是Java语言中已经被赋予特定意义的一些单词，它们在程序上有着不同的用途，不可以把关键字作为			  名字来用。以下是Java的50个关键字：

abstract    assert   boolean   break   byte   case   catch   char   class   const   continue   default   do   double   else  enum   extends   final   finally   float   for   goto   if   implements   import   instanceof   int   interface   long   native   new  package   private   protected   public   return   short   static   strictfp   super   switch   synchronized    this   throw   throws   transient     

try   void   volatile   while

### 2.基本数据类型

​	也称简单数据数据类型，Java语言有8种简单数据类型：boolean，byte，short，int，long，float，double，char。这8种数据类型习惯上被分为四大类型：

​	（1）逻辑类型：boolean

​	（2）字符类型：char

​	（3）整数类型：byte，short，int，long

​	（4）浮点类型：float，double

转义字符：   \n（换行）        \b（退格）        \t（水平制表）           \\' （单引号）      \\"（双引号）

### 3.基本数据类型的转换

​	下列基本类型会涉及数据转换，不包括逻辑类型和字符类型。将这些类型按精度从低到高排列了顺序：

​	byte	<	short <	int	<	long  <	float  <	double.

当把级别低的变量的值付给级别较高的的变量时，系统自动完成数据类型的转换，如

​		float x=100;输出x的值，结果是100.0

当把级别高的变量的值付给级别较低的变量时，必须使用显示类型转换运算（强制类型转换）。格式如下：

​	（类型名） 要转换的值；

​	例如：int  x=（int）34.89，如果输出x的值将是34.

当把一个整数赋值给一个byte、short、int或者long类型变量时，不可以超出这些变量的取值范围，否则必须进行类型转换运算。例如：

​	byte a=(byte)128;  那么a的值就是-128

### 4.数据的输入和输出

#### 1.数据输出System.out.printf

​	System.out.printf的功能完全类似C语言中的printf函数，其一般格式如下：

​		printf（格式控制部分，表达式1，表达式2，...，表达式n）;

​	（1）%md——输出的int类型数据占m列；

​	（2）%m.nf——输出的float类型数据占m列，小数点保留n位；

​	（3）Java提倡用%n表示回行

#### 2.数据的输入Scanner

​	Scanner实在JDK1.5新增的一个类（在java.util包中），可以使用该类创建一个对象：

​		Scanner reader  =   Scanner（System . in）；

然后reader对象调用下列方法（函数），读取用户在命令行输入的各类数据：

​		nextByte(),  nextDouble(),  nextFloat(),  nextInt(),  nextLine(),  nextLong(),  nextShort()

上述方法执行时都会堵塞，等待用户在命令行输入数据回车确认。

例:         

```
  import java.util.*;

		public class Example{

			public static void main(String args[])

			{

				Scanner reader = new Scanner(System.in);

				double sum= 0;

				int m=0;	

				while(redaer.hasNextDouble())

				{

					double x=reader.nextDouble();

					m+=1;

					sum+=x;

				}

				System.out.printf("%d个数的和为：%f\n",m,sum);

				System.out.printf("%d个数的均值为：%f\n",m,sum/m);

			}

		}
```



### 5.数组

​	（1）与C语言不同的是，Java允许使用int类型变量指定数组的大小。例如：

​			int  size = 30;

​			double num[] = new double[size];

​	（2）与C/C++语言不同，Java不允许在声明数组中的方括号内指定数组元素的个数。若声明：

​			int a[12];		或 		int [12]a;  

​			将导致语法错误。

​	（3）提倡使用“数组元素类型   [ ] 数组名字”格式声明数组，如 int [] a

​	（4）length的使用	

​		对于一维数组，”数组名字.length“的值就是数组中元素的个数；

​		对于二维数组，”数组名字.length“的值是它含有的一维数组的个数。例如：

​				float  [] a = new float [12];	a.length的值就是12；

​				int \[][] b = new int\[3][6];  		b.length的值是3。

​	（5）数组的引用

​		1>数组属于引用型变量，因此两个相同类型的数组如果具有相同的引用，他们就有完全相同的元素。

​			例如，对于

​			int []a = {1,2,3}, b = {4,5};

​			数组变量a和b分别存放着不同的引用。

​			但是如果使用了赋值语句“a=b”；那么，此时a的元素和b的元素一致，a中存放的引用和b的相同。

​		2>对于char型数组a，System.out.println(a)不会输出数组a的引用而是输出数组a的全部元素。

​				如：对于char a[] = {'你','好','真','诚'};则System.out.println(a)的结果是“你好真诚”。

​		    如果想输出char型数据的引用，必须让数组a和字符串做并置运算。

​				例如：System.out.println(""+a)输出数组a的引用。

## 三、运算符、表达式和语句

与C语言、C++里面大同小异，因此不做多余的解释，跳讲以下几类

### 1.移位运算符、位运算符和instanceof运算符

#### 		1.移位运算符

​		移位运算符用来对二进制位进行操作，分为左移位操作和右移位操作。

​		（1）左移位运算符

​			符号为<<,是双目运算符。符号左边的操作元称为被移位数，右边的操作数称为位移量，操作元必须是整型的数据。例如， int类型数据7的二进制表示是

​			00000000  00000000  00000000   00000111

​			7<<1 的结果是 00000000  00000000  00000000  00001110

​			假设a是一个被位移的整形数据，n是位移量。a<<n的运算的结果是通过将n的所有位都左移n为，每左移一个位，左边的高阶位上的0或1将被移出丢弃，并用0填充右边的低位。

​			对于byte或short类型数据，a<<n的运算结果是int类型。当进行a<<2时，计算系统先将a升级为int型（对于正数将高位用0填充，负数用1填充），再进行移位运算。因此，如果把a<<1的结果赋值给一个byte类型变量，就必须进行强制类型转换：byte b = (byte)(a<<1);

​			在进行a<<n运算时，如果a是byte、short或int类型数据，系统总是先计算出n%32的结果m，然后进行a<<m运算。对于long类型数据，系统总是先算出n%64的结果m，然后进行a<<m运算。

​		（2）右移位运算符

​			符号为>>，是双目运算符。

​			运算规律类似于左移运算符。

#### 		2.位运算符

​	与&、或|、非~、异或^。

​	位运算符在操作逻辑类型数据时，与逻辑运算符&&、||和！不同的是：位运算要计算完a和b之后再给出运算的结果。例如，x的初值是1，那么经过逻辑比较运算“((y=1)==0)&&((x=6)==6);”后，x的值仍然是1，但是如果经过位运算“((y=1)==0)&((x=6)==6);”后，x的值将是6.

#### 	3.instanceof运算符

​	instanceof是双目运算符，左边的操作元是一个对象，右边是一个类，当左边的对象是右边的类创建的对象时，该运算的结果是true，否则为false。

### 2.表达式

​	Java的一般表达式就是用运算符及操作元连接起来的符合Java规则的式子，简称表达式。一个Java表达式必须能求值，即按照运算符的计算法则，可以计算出表达式的值。

### 3.语句概述

#### 	1.语句分类

​	 Java里的语句可分为以下5类。

​	（1）方法调用语句：对象可以调用类中的方法产生行为。

​	（2）表达式语句：一个表达式的末尾加上“；”就构成了一个语句，称为表达式语句。

​	（3）复合语句：可以用“{”和“}”把一些语句括起来构成复合语句，也称为一个代码块。

​	（4）控制语句：包括条件分支语句、循环语句和跳转语句。

​	（5）package语句和import语句：与类、对象有关，将在第四章讲解。

#### 	2.分支语句

​	1.条件分支语句

​	（1）if-else语句

​	（2）多条件if-else语句

​	2.switch开关语句

#### 	3.跳转语句

​	1.break；

​	2.continue；

## 四、类和对象

​	面向对象编程的三个特征：（1）封装；（2）继承；（3）多态。

### 1.类声明和类体及其构成

​	类是用来定义对象的模板，可以创建对象。当使用一个类创建了一个对象时，我们也说给出了这个类的一个实例。

​	（1）语法上，类由两部分组成：类声明和类体。

​		class 类名 {

​			类体的内容

​		}

​	（2）类体的构成有两个成员：成员变量和方法

### 2.构造方法和对象的创建

​	构造方法是一种特殊方法，它的名字必须与它所在的类的名字完全相同，而且没有类型。Java允许一个类中有若干个不同的构造方法，但这些构造方法的参数必须不同（参数个数不同或者参数类型不同）。两种：有参构造和无参构造。

​	1.对象的声明	

​	格式：

​		类的名字  对象名字；

​	如：		Car  c1;

​	2.为声明的对象分配成员变量

​	格式;

​		对象名字 = new 构造方法名（）;//有参、无参按实际情况决定。

​	如：c1 = new Car(red)

​	会实现下述两件事：

​		（1）为成员变量分配内存空间，然后执行构造方法中的语句。

​		（2）给出一个信息，确保这些成员变量是属于对象c1的。

### 3.对象的引用和实体

​	当用类创建一个对象时，成员变量被分配内存空间，这些内存空间称为该对象的实体或变量，而对象中存放着引用，以确保这些变量由该对象操作使用，因此，如果两个对象有相同的引用，那么就具有同样的实体。

​	Java具有”垃圾收集“机制，Java的运行环境周期地检测某个实体是否已不再被任何对象所引用，如果发现这样的实体，就释放实体占有的内存。

​	没有实体的对象称为空对象。空对象不能使用，即不能让一个空对象去使调用方法产生行为。假如程序中使用了空对象，程序在运行时会出现异常：NullPointerException.由于对象是动态得分配实体，所有Java的编译器对空对象不做检查。因此，编写程序时要避免使用空对象。

### 4.成员变量、方法和方法重载

​	1.类变量和实例变量

​		（1）用关键字static修饰的成员变量称为静态变量或类变量，而没有使用static修饰的成员变量称为实例变量；

​		（2）对象共享类变量；

​		（3）实例变量必须通过对象访问。

​	2.常量

​		（1）如果一个成员变量修饰为final，就是常量，常量的名字习惯用大写字母，如， final  int  MAX;

​		（2）final修饰的成员变量不占内存，意味着在声明final成员变量时必须初始化；

​		（3）对于final修饰的成员变量，对象可以操作使用，但不能做更改操作。

​	3.方法

​		（1）实例方法可以调用该类的实例方法或类方法；类方法只能调用该类的类方法，不能调用实例方法。

​		（2）实例方法可以操作成员变量，无论是实例变量还是类变量；而类方法只能操作类变量。

​		（3）实例方法必须通过对象来调用；类方法可以通过类名调用。

​		（4）方法被调用时，如果方法有参数，参数必须实例化。

​		（5）方法重载是多态性的一种。方法重载是指一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同，即或者是参数个数不同，或者是参数的类型不同。方法的返回类型和参数的名字不参与比较，也就是说，如果两个方法的名字相同，即使类型不同，也必须保证参数不同。

### 5.关键字this

​	this是Java的一个关键字，可以出现在实例方法和构造方法中，但不可以出现在类方法中。

​	1.在构造方法中使用this

​		关键字this可以出现在类的构造方法中，代表使用该构造方法所创建的对象。

​	2.在实例方法中使用this

​		关键字this可以出现在类的实例方法中，代表使用该方法的当前对象。

​	3.类方法中不可以使用this

​		这是因为，类方法可以通过类名直接调用，这时可能还没有任何对象诞生。

​	4.区分成员变量和局部变量

​	（1）成员变量在整个类内有效，局部变量仅在方法内有效。在方法体中声明的变量以及方法的参数称为局部变量，方法的参数在整个方法内有效，方法内定义的局部变量从它定义的位置之后开始有效。

​	（2）如果实例方法中或类方法局部变量的名字与成员变量的名字相同，则成员变量被荫蔽，即这个成员变量在这个方法内暂时失效。

​	（3）如果想在实例方法或类方法内使用成员变量，对于实例方法，成员变量前的“this.”不可以省略；对于类方法，必须显式的使用类名操作类变量。

### 6.包

​	包是Java语言中有效管理类的一个机制。

#### 	1.包语句

​	（1）通过关键字package声明包语句。package语句作为Java源文件的第一条语句，指明该源文件定义的类所在的包。package语句的一般格式如下：

​		package 包名;

​	（2）如果原程序中省略了package语句，源文件中所定义命名的类被隐含的认为是无名包的一部分，即源文件中定义的类在同一个包中，但该包没有名字。

​	（3）包名可以是一个合法的标识符，也可以是若干标识符加“.”分割而成，如;

​			package sunrise;

​			package sun.com.cn;

​	（4）程序如果使用了包语句，如

​			package tom.jiafei;

​		那么，目录结构必须包含如下结构：

​			...\tom\jiafei

#### 	2.使用参数“-d”编译源文件

​	（1）javac可以使用参数“-d”指定生成的字节码文件所在的目录。如果不使用参数“-d”，javac在当前目录下生成字节码文件。

​	（2）如果源文件没有包名，使用参数“-d”可以将字节码文件存放到指定的有效目录中，如

​			javac -d F:\tsinghua\1000 MyFile.java

​		将源文件MyFile.java生成的全部字节码文件存放到F:\tsinghua\1000中。

​	（3）如果源文件使用包语句声明了包名，使用参数“-d”时要格外小心。假设源文件的包名是tom.jiafei，保存在D:\2000中，下述编译命令

​			D:\2000\javac -d  F:\tsinghau\1000    MyFile.java

​		会自动在F:\tsinghau\1000 目录下再新建子目录结构  tom\jiafei，并将字节码文件存放到F:\tsinghua\1000\tom\jiafei中，而下述编译命令

​			D:\2000\javac -d  .MyFile.java

​		会在当前目录D:\2000\下新建子目录结构tom\jiafei，并将字节码文件存放到D:\2000\tom\jiafei中。

### 7.import语句

​	使用import语句可以引入包中的类。

#### 	1.使用类库中的类

​	为了能使用Java提供给我们的类，我们可以使用imort语句来引入包中的类。一个Java源程序中可以有多个import语句，它们必须写在package语句（假如有package语句的话）和源文件中的类的定义之间。Java提供了大约130个包，如：

​		java,applet		包含所有的实现Java Applet的类

​		java.awt			包含抽象窗口工具集中的图形、文本、窗口GUI类

​		java.awt.image	包含抽象窗口工具集中的图形处理类

​		java.lang			包含所有的基本语言类

​		java.io			包含所有的输入输出类

​		java.net			包含所有的实现网络功能的类

​		java.util			包含有用的数据类型类

​	（1）如果要引入一个包中的全部类，则可以用“ * ”来代替，如

​			import  java.awt.*;

​		表示引入包java.awt中所有的类。

​	（2）如果要引入一个包中的个别类，如

​			import java.util.Date;

​		只是引入包java.util中的Date类。

​	（3）系统自动引入java.lang这个包中的全部类，因此不需要使用import语句引入该包中的类。java.lang包是Java语言的核心类库，它包含了运行Java程序必不可少的系统类。

​	（4）如果使用import语句引入了整个包中的类，那么可能会增加编译时间，单据对不会影响程序运行的性能。Java运行平台由所需要的Java类库和虚拟机组成，这些类库被包含在目录\jre\lib中的压缩文件rt.jar中，当程序执行时，Java运行平台从类库中加载程序真正使用的类字节码到内存。

```
//程序示例：使用java.util包中的Date类，用来显示本机的当前时间。

import java.util.Date;

public class Example01{

	public static void main(String args[]){

		Date date = new Date();

		System.out.printf("本地机器的时间：\n%s",date);

	}

}
```

#### 	2.使用自定义包和无名包中的类

​	编译一个源文件，得到该源文件中类的字节码文件，然后供其它类使用，基本原则是：

​	（1）如果应用的程序所需要的其他源文件没有包名，那么必须将该原文件编译后得到的字节码文件和应用程序存放在同一目录中。

​	（2）如果应用的程序所需要的其他源文件有包名，如tom.jiafei，那么可以将该原文件编译后得到的字节码文件存放到应用程序所在目录的tom\jiafei子目录中，如应用程序所在目录为D:ch4,那么在ch4下再建立子目录tom\jiafei，然后将应用程序所需的包名为tom.jiafei的字节码存放到D:\ch4\tom\jiafei中。注意，不可以将包名为tom.jiafei的原文件或字节码存放到应用程序所在的D:\ch4目录中。

​	（3）如果应用的程序所需要的其他源文件有包名，如tom.jiafei，但是没有将该源文件编译后得到的字节码文件存放到到应用程序所在目录的tom\jiafei子目录中，而存放在其他目录的tom\jiafei子目录中，如C:\1000\tom\jiafei中，那么必须在classpath中指明tom.jiafei包的位置，可以在命令行中执行如下命令：

​			set classpath=E:\jdk1.6\jre\lib\rt,jar;.;C:\1000

​		或将上述命令添加到classpath值中。

​	（4）对于上述（1）（2）中，不必去修改classpath的值，因为默认的classpath的值是

​			E:\jdk1.6\jre\lib\rt,jar;.;

​		其中的“,;”表示可以加载应用程序当前目录中的无名包类，而且当前目录下的子目录可以作为包的名字来使用。

#### 	3.避免类名混淆

​	在一个源文件使用一个类时，只要不引起混淆，就可以省略该类的包名，但在某些特殊情况下不能省略包。

​	（1）区分无名包和有名包的类

​	（2）区分有名包的类

### 8.访问权限

​	访问权限是指类创建的对象是否可以通过“ . ”运算符访问分配给自己的变量、是否可以通过“ . ”运算符调用类中的实例方法和类方法。而类中的实例方法总是可以操作该类中的实例变量和类变量；类方法总是可以操作该类中的类变量，与访问限制符没有关系。

#### 	1.私有变量和私有方法

​		关键字private修饰。

#### 	2.共有变量和共有方法

​		关键字public修饰。

#### 	3.友好变量和友好方法

​		（1）不用private、public、protected修饰符的成员变量和方法被称为友好变量和友好方法。

​		（2）在另一个类中用类A创建了一个对象后，如果这个类与类A在同一个包中，那么该对象能访问自己的友好变量和友好方法。在任何一个与Tom在同一个包中的类中，也可以通过类A的类名访问类A的友好类变量和友好类方法。

​		（3）在源文件中编写命名的类总是在同一包中的。如果源文件使用import语句引入了另外一个包中的类，并用该类创建了一个对象，那么该类的这个对象将不能访问自己的友好变量和友好方法。

#### 	4.受保护的成员变量和方法

​		关键字protected修饰。

#### 	5.public类与友好类

​		（1）类声明时，如果用关键字class前面加上关键字public，就称这样的类是一个public类，不能用protected和private修饰类。可以在任何一个类中使用public类创建对象。

​		（2）如果一个类不加public修饰，如

​				class A{

​					.......

​				}

​			这样的类被称为友好类，另一个类中使用友好类创建对象时，要保证它们在同一个包中。

​		（3）//****假设对象a是类A创建的，对象队成员的访问权限如下表

|           对象a的位置            | private成员 | 友好成员 | protected成员 | public成员 |
| :------------------------------: | :---------: | :------: | :-----------: | :--------: |
|        在类A中，a访问成员        |    允许     |   允许   |     允许      |    允许    |
|  在与A同包的另一个类中a访问成员  |   不允许    |   允许   |     允许      |    允许    |
| 在与A不同包的另一个类中a访问成员 |   不允许    |  不允许  |    不允许     |    允许    |

#### 	6.关于构造方法

​	private、public、protected修饰符的意义同样适用于构造方法。如果一个类没有明确的声明构造方法，那么public类的默认构造方法是public，友好类的默认构造方法是友好的。注意，如果一个public类定义声明的构造方法中没有public，那么在另一个类中使用该类创建对象时，使用的构造方法就不是public，创建对象就受到一定的限制。

### 9.对象的组合

​	一个类的成员变量可以是Java允许的任何数据类型，因此一个类可以把对象作为自己的成员变量，如果用这样的类创建对象，那么该对象中就会有其他对象，也就是说，该对象将其他对象作为自己的组成部分（这就是人们常说的Hash-A），或者说该对象是有几个对象组合而成。

### 10.基本类型数据的类包装

​	Java的基本数据类型包括：byte、interesting、short、long、float、double、char。Java也提供了基本数据类型相关的累，实现了对基本数据类型的封装。这些类在java.lang包中，分别是：Byte、Integer、Short、Long、Float、Double和Character类。

​	（1）Double和Float类

​	使用构造方法	Double(double num)	创建一个Double类型的对象；

​	使用构造方法	Float(float num)	创建一个Float类型的对象；

​	Double对象调用doubleValue()方法可以返回该对象含有的double类型数据，

​	Float对象调用FloatValue()方法可以返回该对象含有的Float类型数据。

​	（2）Byte、Integer、Short、Long类

​	下述构造方法分别可以创建Byte、Integer、Short、Long类型的对象：

​		Byte(byte num);

​		Integer(int num);

​		Short(short num);

​		Long(long num);

​	Byte、Integer、Short、Long对象分别调用byteValue()、intValue()、shortValue()和longValue()方法返回该对象含有的基本数据类型。

​	（3）Character类

​	使用构造方法	Character(char c)	创建一个Character类型的对象；

​	Character对象调用charValue()方法可以返回该对象含有的char类型数据。

​	Character类还包括一些类方法，这些方法可以直接通过类名调用，用来进行字符分类，如判断一个字符是否是数字字符或改变一个字符的大小写等。

​	Character类中的一些常用类方法如下：

​	public static boolean isDigit(char ch)	——如果ch是数字字符方法返回true，否则返回false。

​	public static boolean isLetter(char ch)	——如果ch是字母字符方法返回true，否则返回false。

​	public static boolean isLetterOrDigit(char ch)	——如果ch是数字字符或字母字符方法返回true，否则返回false。

​	public static boolean isLowerCase(char ch)	——如果ch是小写字母字符方法返回true，否则返回false。

​	public static boolean isUpperCase(char ch)	——如果ch是大写字母字符方法返回true，否则返回false。

​	public static char toLowerCase(char ch)		——返回ch的小写形式。

​	public static char toUpperCase(char ch)		——返回ch的大写形式。

​	public static boolean isSpaceChar(char ch)	——如果ch是空格返回true。

### 11.对象数组

​	数组的元素是对象。例如：

​		Integer []m;

​		m = new Integer[10];

​	注意，上述代码仅定义了数组m有10个元素，并且每个元素都是Integer类型的对象，但这些对象目前都是空对象，因此在使用数组m中的对象之前，应当创建数组所包含的对象。例如：

​		m[0] = new Integer(120);

### 12.反编译和文档生成器

​	使用SDK提供的反编译器javap.exe可以将字节码反编译为源码，查看源码类中的public方法名字和public成员变量的名字，如

​		javap java.awt.Button	——将列出Button中的public方法和public成员变量。

下列命令

​		javap -private java.awt.Button	——将列出Button中的全部方法和成员变量。

​		使用SDK提供的javadoc.exe可以制作源文件类结构的html格式文档：

​			javadoc Example.java

​		这时在文件夹test中将生成若干个html文档，查看这些文档可以知道源文件中类的组成结构，如类中的方法和成员变量。

​		使用javadoc时，也可以使用参数“-d”制定生成文档所在的目录，如

​			javadoc -d  F:\gxy\book  Example.java

### 13.JAR文件的使用

​	Java应用程序在运行时，需要将使用到的类的字节加载到内存，因此，对字节码文件所在的位置就有着特殊的要求。以下分4种情形。

​	1.使用当前应用程序所在目录中没有包名的类

​		对于当前应用程序所在目录中没有包名的类，可直接加载使用。

​	2.使用Java运行环境中类库的类

​		Java运行环境所提供的类库中的类都是有包名的，应用程序必须使用import语句引入相应包中的类。

​	3.使用应用程序当前目录的子目录中的类

​		应用程序当前目录下的子目录可以作为用户自定义包的包名，具有该包名的类必须存放在这些子目录中，应用程序就可以使用import语句引入用户自定义包中的类了。

​	4.使用Java运行环境扩展中的类

​		可以使用jar.exe命令把一些类的字节码文件压缩成一个JAR文件，然后将这个JAR文件存放到Java运行环境的扩展中，即将该JAR文件存放在JDK安装目录下的jre\lib\ext文件夹中。这样，Java应用程序就可以使用该JAR文件中的类来创建对象。

​	（1）有包名的类

​		下列TestOne和TestTwo类的包名为moon.star。

```
TestOne.java

			package moon.star;		//包语句

			public class TestOne{

				public void fTestOne(){

					System.out.println("I am a method In TestOne xlass");

				}

			}

		TestTwo.java

			package moon.star;		//包语句

			public class TestTwo{

				public void fTestTwo(){

					System.out.println("I am a method In TestTwo class");

				}

			}
```

​		将上述TestOne.java和TestTwo.java保存到某个\moon\star目录中，如C:\1000\moon\star，然后进入该目录分别编译这两个源文件。

​		现在将C:\1000\moon\star目录中的TestOne.class和TestTwo.class压缩成一个JAR文件Jerry.jar。首先编写一个清单文件：hello.mf(Manifestfiles)。

​							hello.mf

​								Manifest-Version: 1.0

​								Class: moon.star.TestOne moon.star.TestTwo

​								Created-By: 1.5

​		在编写清单文件hello.mf时，在“Manifest-Version:”与“1.0.”之间、“Class:”与类之间，以及“Created-By:”与“1.5”之间必须有且仅有一个空格。

​		为了使用jar命令来生成一个JAR的文件，首先需要进入到C:\1000目录（不可以进入到C:\1000\moon\star），即进入包名的上一层目录，然后使用jar命令来生成一个名字为Jerry.jar的文件，如下所示;

​			C:\1000\jar\ cfm Jerry.jar hello.mf moon\star\TestOne.class moon\star\TestTwo.class

​		如果C:\1000\moon\star中只有TestOne.class和TestTwo.class两个字节码文件，也可以使用如下命令;

​			C:\1000\jar\ cfm Jerry.jar hello.mf moon\star\\*.class

​		最后，将jar命令在C:\1000目录中生成的Jerry.jar文件复制到Java运行环境的扩展中，即将该Jerry.jar文件存放在JDK安装目录的jre\lib\ext文件夹中。

​		下面的USE类中使用import语句引入了Jerry.jar中的TestOne、TestTwo类。

​			

```
import moon.star.*;

			public class USE{

				public static void main(String args[]){

					TestOne a = new TestOne();

					a.fTestOne();

					TestTwo b = new TestTwo();

					b.fTestTwo();

				}

			}
```

​	（2）无包名的类

​		如果TestOne和TestTwo类没有包名，只需将TestOne.java和TestTwo.java保存到C:1000中、编译得到字节码文件。将（1）中清单文件中类的包名去掉后保存到C:\1000中，进入道C:\1000目录，使用jar命令;

​			C:\1000\jar cfm Jerry,jar hello.mf TestOne.class TestTwo.class

​		如果C:\1000只有TestOne.class和TestTwo.class两个字节码文件，也可以使用如下命令;

​			C:\1000\jar cfm Jerry,jar hello.mf*.class

​		最后，将jar命令在C:\1000目录中生成的Jerry.jar文件复制到JDK安装目录的jre\lib\ext文件夹中，应用程序及可以直接使用Jerry.jar文件中的TestOne.class和TestTwo.class。

## 五、继承、接口和泛型

### 1.子类和父类

​	（1）继承是一种由已有的类创建新类的机制。由继承而得到的类称为子类（扩展），被继承的类称为父类（超类）。Java不支持多重继承，即子类只能有一个父类。

​	（2）在类的声明中，使用关键字extends来声明一个类是另外一个类的子类，格式如下：

​			class 子类名 extends 父类名{

​				......

​			}

​	（3）如果一个类的声明中没有使用关键字extends，这个类被系统默认为是Object的子类，Object是包java.lang中的类。也就是说，类声明

​			class A{

​				......

​			}

​	与

​			class A extends Object{

​				......

​			}		

​	是等同的。

### 2.子类的继承性

​	1.继承的定义

​	2.子类和父类在同一包中的继承性

​		如果子类和父类在同一个包中，那么子类自然地继承了其父类中不是private的成员变量作为自己的成员变量，也自然地继承了父类中不是private的方法作为自己的方法。继承的成员变量以及方法的访问权限保持不变。

​	3.子类和父类不在同一包中的继承性

​		如果子类和父类不在同一个包中，那么子类继承了父类的protected、public成员变量作为子类的成员变量，并且继承了父类的protected、public方法，继承的成员变量或方法的访问权限保持不变，但子类不能继承父类的友好变量和友好方法。

### 3.子类对象的构造过程

​	当用子类的构造方法创建一个子类的对象时，子类的构造方法总是先调用父类的某个构造方法。也就是说，如果子类的构造方法，没有明确的指明使用父类的哪个构造方法，子类就调用父类的不带参数的构造方法。因此，我们可以这样理解子类创建的对象：

​	1.将子类中声明的成员变量作为子类对象的成员变量。

​	2.父类的成员变量也都分配了内存空间但只将其中一部分（继承的那部分）作为子类的成员变量。

### 4.成员变量的隐藏和方法的重写

​	1.成员变量的隐藏

​		（1）子类也可以隐藏继承的成员变量，当在子类中定义的成员变量只要和父类中的成员变量同名时（不必类型相同），子类就隐藏了继承的成员变量，即子类重新定义了这个成员变量。

​		（2）尽管子类可以隐藏从父类继承类的成员变量，但是子类仍然可以使用从父类继承的方法操作被隐藏的成员变量。

​	2.方法重写

​		子类可以隐藏自己继承的方法，子类通过方法重写来隐藏继承的方法。方法重写是指：子类中定义一个方法，并且这个方法的名字、返回类型参数个数和类型与从父类继承的方法完全相同。子类通过方法的重写可以隐藏继承的方法，子类通过方法的重写可以把父类的状态和行为改变为自身的状态和行为。如果父类的方法f()可以被子类继承，子类就有权利重写f(),一旦子类重写了父类的方法f()，那么子类对象调用方法f()一定是调用重写的方法f()。重写的方法既可以操作继承的成员变量，也可以操作子类声明定义的成员变量。如果子类想使用被隐藏的方法，必须使用关键字super。

​		重写父类的方法时，不可以降低方法的访问权限。

​	3.访问修饰符protected的进一步说明

### 5.关键字super

​	1.使用super调用父类的构造方法

​	子类如果想使用父类的构造方法，必须在子类的构造方法中使用且必须使用关键字super来表示，而且super必须是子类构造方法中的第一条语句。子类在创建对象时，子类的构造方法总是先调用父类的某个构造。也就是说，如果子类的构造方法没有明确地指明父类的哪个构造方法，子类就调用父类的不带参数的构造方法。因此，如果在子类的构造方法中，没有使用关键字super调用父类的某个构造方法，那么默认有

​		super();

​	语句，即调用父类的不带参数的构造方法。如果父类没有提供不带参数的构造方法，会出现错误。

​	2.使用super操作被隐藏的成员变量和方法

​	子类中使用被隐藏的成员变量或方法，可以使用关键字super。

### 6.final类和final方法

​	1.final类能被继承，即不能有子类，格式如下;

​		final class A{

​			......

​		}

​	2.final方法不能被重写，即不允许子类重写隐藏继承的final方法，final方法的行为不允许子类篡改。

### 7.对象的上转型对象

​	1.定义

​	假设，B是A的子类或间接子类，用子类B创建一个对象，并把这个对象的引用放到类A声明的对象中时，如：

​			A a;

​			B b = new B();

​			a = b;

​	那么，就称对象a是子类对象b的上转型对象。

​	2.对象创建过程及其特点

​	对象的上转型对象的实体是子类负责创建的，但上转型对象会失去原对象的一些属性和功能。上转型对象具有如下特点：

​		（1）上转型对象不能操作子类声明定义的成员变量（失去了这部分属性），不能使用子类声明定义的方法（失去了一些功能）。

​		（2）上转型对象可以代替子类对象区调用子类重写的实例方法。如果子类重写的方法是实例方法，那么上转型对象调用重写的方法时，就是通知对应的子类对象去调用这些方法。因此，如果子类重写了父类的某个实例方法后，子类对象的上转型对象调用这个方法时，一定是调用了这个重写的方法。

​		（3）上转型对象可以调用子类继承的成员变量和隐藏的成员变量。

​			可以将对象的上转型对象再强制转换到一个子类对象，这时该子类对象又具备了子类的所有属性和功能。

​	上转型对象不是父类创建的对象，而是子类对象的“简化”形态，它不关心子类新增的功能，只关心子类继承和重写的功能。

### 8.继承和多态

​	与继承有关的多态性是指父类的某个实例方法被其子类重写时，可一个位产生各自的功能行为，指同一个操作被不同类型对象调用时可能产生不同的行为。

### 9.abstract类

​	1.定义：用关键字abstract修饰的类称为抽象类（abstract类）。

​	2.特点	

​	（1）抽象类中可以有抽象方法。

​		与普通的类相比，抽象类可以有抽象方法（abstract方法），也可以有非抽象方法。对于抽象方法，只允许声明，不允许实现，而且不允许使用final和abstract同时修饰一个方法。

​	（2）抽象类不能用new运算创建对象

​		如果一个非抽象类是某个抽象类的子类，那么它必须重写父类的抽象方法 ，给出方法体，即在子类中将抽象方法重新声明，但必须去掉abstract修饰，同时保证声明的方法名字、返回类型、参数个数和类型与父类的抽象方法完全相同。这就是为什么不允许使用final和abstract同时修饰一个方法的原因。

​	（3）做上转型对象

​		尽管抽象类不能创建对象，但它的非抽象种类必须重写其中的全部抽象方法，这样一来，就可以让抽象类声明的对象成为其子类对象的上转型对象，并调用子类重写的方法。

​	（4）抽象类也可以没有抽象方法。如果一个抽象类是abstract类的子类，它可以重写父类的抽象方法，也可以继承这个抽象方法。	

### 10.面向抽象编程 

​	核心思想：

​	1.抽象细节

​	2.面向抽象设计类

### 11.接口和接口回调

​	Java不支持多继承性，即一个类只能有一个父类。单继承性使得Java简单、易于管理程序。为了克服单继承的缺点，Java使用了接口，一个类可以实现多个接口。

​	关键字interface来定义一个接口。接口的定义和类的定义相似，分为接口的声明和接口体。

​	1.接口的声明和使用

​	（1）接口的声明

​		格式：	interface 接口的名字

​	（2）接口体

​		接口体中包含常量定义和方法定义。接口体中只允许进行方法的声明，不允许提供方法的实现，所以方法的定义没有方法体。

​	（3）使用

​		一个类通过使用关键字implements声明自己实现一个或多个接口。如果实现多个接口，用逗号隔开接口名，如

​			class A implements Printable,Addable

​		类A使用接口Printable和接口Addable，而

​			class Dog extends Animal implements Eatable,sleepable

​		类Dog实现接口Eatable和接口sleepable。

​		如果一个类实现某个接口，那么这个类必须实现该接口的所有方法，即为这些方法提供方法体。在类中实现接口的方法时，方法的名字、返回类型、参数个数及类型必须与接口中的完全一致。注意，接口中的默认方法是public和abstract，接口在声明方法时可以省略方法前面的关键字public和abstract，但是类在实现接口方法时，一定要用public来修饰。另外，如果接口的方法的返回类型不是void型，那么在类中实现该接口方法时，方法体中至少要有一个return语句；如果是void类型，类体除了“{”和“}”外，也可以没有任何语句。类实现的接口方法以及接口中的常量可以被类的对象调用。

​		Java提供的接口都在相应的包中，通过引入包可以使用Java提供的接口，也可以自己定义接口，一个Java源文件就是由类和接口组成的。

​		接口声明时，如果关键字interface前面加上关键字public，就称这样的接口是一个public接口，可以被任何一个接口使用。如果不加public，就称为友好接口类，可以被同一包中的类使用。

​		如果父类实现某接口，那么子类也就自然实现了该接口，子类不必再显示式地使用关键字implements声明自己实现这个接口。

​		接口也可以被继承，即通过关键字extends声明一个接口是另一个接口的子接口。由于接口中的方法和常量都是public的，子类将继承父类接口中的全部方法和常量。

​	2.接口与多态

​	（1）Java支持继承，但不支持多继承，即一个类只能有一个父类。

​	（2）Java使用了接口，一个类可以实现多个接口。

​	（3）不同的类可以使用相同的接口，一个类可以实现多个接口。

### 12.接口回调

​	1.接口回调

​	接口回调是多态的另一种体现。接口回调是指：可以把使用某一接口的类创建的对象的引用赋给该接口声明的接口变量中，那么该接口变量就可以调用被类实现的接口中的方法，当接口变量调用被类实现的接口中的方法时，就是通知相应的对象调用接口的方法，这一过程成为对象功能的接口回调。不同的类在使用同一接口时，可能具有不同的功能体现，即接口的方法体不必相同，因此接口回调可能产生不同的行为。

​		例：

```
interface ShowMessage{
    void showTradeMark();
}
class TV implements ShowMessage{
    public void showTradeMark(){
        System.out.println("我是电视机");
    }
}
class PC implements ShowMessage{
    public void showTradeMark(){
        System.out.println("我是电脑");
    }
}
public class hhh{
    public static void main(String args[]){
        ShowMessage sm;		//声明接口变量sm
        sm = new TV();		//接口变量sm中存放对象的引用
        sm.showTradeMark(); //接口sm回调ShowTradeMark()方法
        sm = new PC();		//接口变量sm中存放对象的引用
        sm.shoeTradeMark();	//接口回调
    }
}
```

2.接口作为参数

当一个方法的参数是一个接口类型时，如果一个类实现了该接口，那么就可以把该类的实例的引用传值给该参数，参数可以回调类实现的接口方法。

### 13.面向接口编程

​	我们可以通过在接口中声明若干个抽象方法，表明这些方法的重要性，方法体的具体细节由实现接口的类去完成。试用接口进行程序设计的核心思想是使用接口回调，即接口变量存放实现该接口的类的对象的引用，从而接口变量就可以回调类实现的方法。

​	面向对象也可以体现程序设计的“开-闭原理”（Open-Closed Principle），即对扩展开放，对修改关闭。

​	为了满足“开-闭原理”，在程序设计好后，首先对接口的修改“关闭”，否则一旦修改接口，如为它再增加一个抽象方法，那么实现该接口类都需要做出修改。程序设计好后，应当对增加实现该接口的类“开放”，即在程序中再增加实现该接口的类时，不需要修改其他重要的类。

### 14.抽象类与接口的比较

​	1.抽象类和接口都可以有抽象方法

​	2.接口中只可以有常量；而抽象类中既可以有常量也可以有变量

​	3.抽象类中可以有非抽象方法，接口不可以

### 15.内部类、匿名类、异常类和泛型类

​	1.内部类

​	（1）定义：Java支持在一个类中声明另一个类，这样的类称为内部类，而包含内部类的类称为内部类的外嵌类。

​	（2）规则：一个类把内部类看成是自己的成员。内部类的外嵌类的成员变量在内部类中仍然有效，内部类中的方法也可以调用外嵌类中的方法。内部类的类体中不可声明类变量和类方法。外嵌类可以把内部类声明对象作为外嵌类的成员。

​	2.匿名类

​	（1）与类有关的匿名类

​	（2）与接口有关的匿名类

​	3.异常类

​	（1）try-catch语句

​	（2）自定义异常类

​		我们可以扩展Exception类定义自己的异常类，然后规定哪些方法产生这样的异常。一个方法在声明时可以使用关键字throws声明抛出所要求产生的若干个异常，并在该方法的方法体中具体给出产生异常的操作，即用相应的异常类创建对象，这将导致该方法结束执行并抛出所创建的异常对象。

​	例如：求偶证书的平方根，自己定义一个异常类，当向该方法传递的参数是负数时发生MyException异常。

```
class MyException extends Exception{
    String message;
    MyException(int n){
        message=n+"不是正数。";
    }
    public String getMessage(){
        return message;
    }
}
class A{
    public void f(int n) throws MyException{
        if(n<0){
            MyException ex=new MyException(n);
            throw(ex);
        }
        double number = Math.sqrt(n);
        System.out.println(n+"的平方根： "+number);
    }
}
public class Test02{
    public static void main(String args[]){
        A a=new A();
        try{
            a.f(28);
            a.f(-8);
        }
        catch(MyException e){
            System.out.println(e.getMyException());
        }
    }
}
```



## 六、字符串和正则表达式

## 七、常用实用类

## 八、线程

## 九、输入流和输出流

## 十、图形用户界面设计

## 十一、Java中的网络编程

## 十二、Java数据库操作

## 十三、Java Applet

